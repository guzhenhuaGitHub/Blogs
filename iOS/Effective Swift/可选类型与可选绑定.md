# 可选类型与可选绑定
## 可选类型
在值可能不存在的时候使用可选类型。一个可选类型代表有两种可能性：有一个值，你可以解包可选类型来访问该值，或者根本没有值。

C 或 Objective-C 中不存在可选类型的概念。Objective-C 中最接近的东西就是从返回对象的方法返回 nil 的能力，nil 的意思是“没有有效的对象”。但是，这只适用于对象——它不适用于结构，基本的 C 类型或枚举值。对于这些类型，Objective-C 方法通常会返回一个特殊值（如 NSNotFound）来指示缺少值。这种方法假设方法的调用者知道有一个特殊的值来测试，并记得检查它。Swift 的可选类型可以让你指出没有任何类型的值，而不需要特殊的常量。

以下是如何使用可选类型来应对值缺失的一个例子。Swift 的 Int 类型有一个初始化方法，它试图将一个 String 值转换成一个 Int 值。但是，并不是每个字符串都可以转换成一个整数，字符串"123"可以转换为数字值123，但字符串"hello, world"没有一个明显的数值要转换。

下面的例子使用初始化方法来尝试将一个字符串转换为一个 Int：
```
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
```
因为初始化方法可能会失败，所以它返回一个可选的 Int，而不是一个 Int。可选的 Int 被写为 Int?，而不是 Int。问号标识它所包含的值是可选的，这意味着它可能会包含一些 Int 值，或者它可能根本不包含任何值。（它不能包含任何其他内容，比如 Bool 值或 String 值，它可以是一个 Int，或者什么也不是。）

## nil
通过赋值给它一个特殊的值 nil 来设置一个可选变量为无值状态：
```
var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value
```
你不能对非可选类型的常量和变量使用 nil。如果代码中的某个常量或变量需要在某些条件下没有值的情况下工作，则始终将其设置为适当类型的可选值。

如果你定义了一个可选变量而不提供默认值，则该变量会自动设置为 nil：
```
var surveyAnswer: String?
// surveyAnswer is automatically set to nil
```
Swift 的 nil 与 Objective-C 中的 nil 不相同。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是一个指针，它是缺少某种类型的值。任何类型的可选值都可以设置为 nil，而不仅仅是对象类型。

## If 语句和强制解包
你可以使用 if 语句通过将可选值与 nil 进行比较来确定可选项是否包含值。你使用“等于”运算符（==）或“不等于”运算符（!=）执行此比较。

如果一个可选值有一个值，则认为是“不等于” nil：
```
if convertedNumber != nil {
print("convertedNumber contains some integer value.")
}
// Prints "convertedNumber contains some integer value."
```
一旦确定可选值包含值，可以通过在可选名称的末尾添加感叹号（！）来访问其基础值。感叹号有效的说：“我知道这个可选值肯定有值，请使用它”。这被称为强制解包一个可选的值。
```
if convertedNumber != nil {
print("convertedNumber has an integer value of \(convertedNumber!).")
}
// Prints "convertedNumber has an integer value of 123."
```
试着用！访问不存在的可选值会触发运行时错误。在使用！强制解包它的值之前，一定要确保一个可选值不为 nil。
## 可选绑定
你使用可选绑定来发现可选值是否包含值，如果有，则使该值可用作临时常量或变量。可选绑定可以与 if 和 while 语句一起使用，以检查可选内部的值，并将该值提取为常量或变量，作为单个操作的一部分。

为 if 语句编写一个可选绑定，如下所示：
```
if let constantName = someOptional {
statements
}
```
你可以重写之前部分中的示例以使用可选绑定而不是强制解包：
```
if let actualNumber = Int(possibleNumber) {
print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"
```
这段代码可以读作：

“如果由 Int(possibleNumber) 返回的可选 Int 包含一个值，则将一个名为 actualNumber 的新常量设置为可选的值。”

如果转换成功，那么 actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被初始化为包含在可选的值中，所以没有必要使用！后缀来访问它的值。在这个例子中，actualNumber 只是用来打印转换的结果。

由于命名事物非常困难，所以通常的做法是将解包后的常量与可选的名称相同（从而覆盖了可选值）。
```
if let possibleNumber = Int(possibleNumber) {
...
}
```
你可以使用可选绑定的常量或变量。如果你想在 if 语句的第一个分支内操作 actualNumber 的值，你可以写 if var actualNumber，而且可选的变量可以作为一个变量而不是一个常量。

你可以根据需要在单个 if 语句中包含尽可能多的可选绑定和布尔检测，并用逗号分隔。如果可选绑定中的任何值为 nil，或者任何布尔检测的计算结果为 false，则整个 if 语句的条件被认为是错误的。以下 if 语句是等价的：
```
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"

if let firstNumber = Int("4") {
if let secondNumber = Int("42") {
if firstNumber < secondNumber && secondNumber < 100 {
print("\(firstNumber) < \(secondNumber) < 100")
}
}
}
// Prints "4 < 42 < 100"
```
在 if 语句中使用可选绑定创建的常量和变量仅在 if 语句的主体中可用。相反，使用 guard 语句创建的常量和变量在 guard 语句后面的代码行中可用。
## 隐式解包
如上所述，可选类型表示常量或变量被允许具有“无值”。可以使用 if 语句检查可选值，以查看是否存在值，并且可以使用可选绑定有条件的解包，以访问可选值（如果存在）。

有时从程序的结构中可以清楚的看到，在第一次设置值之后，可选值将始终有一个值。在这些情况下，每次访问时都不需要检查可解包可选的值，因为可以安全地假定所有的时间都有一个值。

这些可选值被定义为隐式解包可选值。你写一个隐式解包的可选值，在你想要的可选类型之后放置一个感叹号（String！）而不是一个问号（String？）

当一个可选值在第一次被定义后立即存在时，隐式解包的可选值是有用的，并且可以肯定地假定存在于其后的每一个点上。Swift 中隐式解包可选值的主要用途是在类初始化期间。

隐式解包可选值的背后是普通可选值，但也可以像非可选值一样使用，而不必在每次访问时解包可选值。下面的例子展示了一个可选 String 和一个隐式解包的可选 String 以一个明确的字符串的形式访问它们的包装值时行为的区别：
```
et possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
```
你可以认为隐式解包可选值是有在使用时自动解包权限的值就好。每次使用时，不要在可选名称后面放置感叹号，而是在声明它时在可选类型后面放置感叹号。

如果隐式解包的可选值为 nil，并且你尝试访问其包装的值，则会触发运行时错误。结果与在不包含值的普通可选值之后放置感叹号完全相同。

你仍然可以像一个普通的可选值那样对待一个隐式解包可选值，来检查它是否包含一个值：
```
if assumedString != nil {
print(assumedString!)
}
// Prints "An implicitly unwrapped optional string."
```
你也可以使用一个带有可选绑定的隐式解包可选值，在一个语句中检查和解包它的值。
```
if let definiteString = assumedString {
print(definiteString)
}
// Prints "An implicitly unwrapped optional string."
```
当稍后变量为 nil 时，不要使用隐式解包可选值。如果你需要在变量的生命周期中检查 nil 值，请始终使用正常的可选类型。
## Nil-Coalescing 运算符
Nil-Coalescing 运算符（a ?? b）如果 a 包含一个值则解包它，或者返回一个默认值 b（如果 a 是 nil）表达式 a 始终是可选的类型，表达式 b 必须匹配存储在 a 中的类型。

Nil-Coalescing 运算符是以下代码的简写：
```
a != nil ? a! : b
```
上面的代码使用三元条件运算符，并强制解包（a!）来访问 a 不为 nil 时包装的值，否则返回 b。Nil-Coalescing 运算符提供了一种更简洁的方式以简洁易懂的形式封装这个条件检查和解包。如果 a 的值不是 nil，则不计算 b 的值。这就是所谓的短路计算。

下面的示例使用 nil-Coalescing 运算符在默认的颜色名称和可选的用户定义的颜色名称之间进行选择：
```
let defaultColorName = "red"
var userDefinedColorName: String?   // defaults to nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"
```
userDefinedColorName 变量被定义为一个可选的 String，默认为 nil。由于 userDefinedColorName 是可选类型，因此可以使用 nil-Coalescing 运算符来获得其值。在上面的例子中，运算符用于确定名为 colorNameToUse 的字符串变量的初始值。因为 userDefinedColorName 是 nil，表达式 userDefinedColorName ?? defaultColorName 返回 defaultColorName 的值，或者“red”。

如果将一个非 nil 值赋给 userDefinedColorName 并再次执行 nil-Coalescing 运算符检查，则将使用包装在 userDefinedColorName 中的值而不是缺省值。
```
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName is not nil, so colorNameToUse is set to "green"
```
如果觉得我写的还不错，请关注我的微博[@小橘爷](http://weibo.com/yanghaoyu0225)，最新文章即时推送~
