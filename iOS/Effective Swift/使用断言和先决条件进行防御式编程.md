# 使用断言和先决条件进行防御式编程
断言和先决条件是在运行时发生的检查。在执行任何进一步的代码之前，使用它们来确定满足基本条件。如果断言或先决条件中的布尔条件结果为 true，则代码执行将像往常一样继续。如果条件结果为 false，程序的当前状态是无效的，代码执行结束，你的程序被终止。

你使用断言和先决条件来表达你所假设以及编码时的期望，这样你就可以将它们包含在代码中。断言有助于你在开发过程中发现错误和不正确的假设，并且先决条件可帮助你检测生产中的问题。

除了在运行时验证你期望外，断言和先决条件也成为代码中有用的文档形式。与上述错误处理中讨论的错误条件不同，断言和先决条件不用于可恢复或预期的错误。因为失败的断言或先决条件表明一个无效的程序状态，没有办法捕获失败的断言。

使用断言和先决条件不能替代设计代码的方式，以至于不可能出现无效条件。但是，使用它们强制执行有效的数据和状态会导致你的应用程序在发生无效状态时更可预测地终止，并有助于使问题更易于调试。一旦检测到无效状态，立即停止执行也有助于限制由该无效条件造成的损害。

断言和先决条件之间的区别在于它们被检查时：只在 debug 版本中检查断言，但在 debug 和 production 版本中都会检查先决条件。在 production 版本中，断言内的条件不被评估。这意味着你可以在开发过程中使用尽可能多的断言，而不会影响性能。
## 用断言进行调试
你可以通过调用 Swift 标准库中的 `assert(_:_:file:line:)`函数来编写一个断言。如果条件的结果为假，则将此函数传递给一个表达式，其值为 true 或 false，并显示一条消息，例如：
```
let age = -3
assert(age >= 0, "A person's age can't be less than zero.")
// This assertion fails because -3 is not >= 0.
```
在这个例子中，如果 age >= 0的计算结果为真，代码执行继续，即 age 的值是非负的。如果 age 的值是负数，如上面的代码所示，那么 age >=0 的计算结果为 false，断言失败，终止应用程序。

你可以省略断言信息——例如，当它只是重复作为条件。
```
assert(age >= 0)
```
如果代码已经检查了条件，则使用 `assertionFailure(_:file:line:)` 函数来指示断言失败，例如：
```
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age > 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```
使用部分就到这里了，接下来我们看一下断言函数的声明：
`assert(_:_:file:line:)` 函数的完整声明为：
```
func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)
```
其参数的含义是：
- condition
要测试的条件。 条件仅在  playgrounds 和 -Onone 编译的版本中进行评估。
- message
如果条件评估为 false，则打印一个字符串。 默认值是一个空字符串。
- file
断言失败时用消息打印的文件名。 缺省值是调用 `assert(_:_:file:line:)` 的文件。
- line
如果断言失败，则与行消息一起打印的行号。 缺省值是调用 `assert(_:_:file:line:)` 的行号。

在这里要注意，condition 和 message 这两个参数均使用了 @autoclosure，把 Bool 和 String 做了一层包装。这样做的好处是，在真正调用这个方法之前，不必实际传入一个参数，是类似于懒加载和短路计算的一个减少开销的小 tips。

在编译参数不同的情况下，断言的表现也不同：
- 在 playgrounds 和 -Onone 编译的版本（Xcode Debug 配置的默认版本）中：如果条件评估为 false，则在打印消息后停止程序执行。
- 在-O 编译的版本中（Xcode 的 Release 配置的默认值），不评估条件，并且没有影响。
- 在-Ounchecked 编译的版本中，不评估条件，但优化器可能会认为它始终评估为 true。 未能满足这个假设是一个严重的编程错误。
## 执行先决条件
当条件有可能是错误的时候使用前提条件，但是对于代码继续执行肯定是正确的。例如，使用前提条件来检查下标是否超出范围，或检查函数是否已传递有效值。

你通过调用 `precondition(_:_:file:line:) ` 函数来编写前提条件。如果条件的结果为假，则将此函数传递给一个表达式，其值为 true 或 false，并且显示一条消息。例如：
```
// In the implementation of a subscript...
precondition(index > 0, "Index must be greater than zero.")
```
你还可以调用 `preconditionFailure(_:file:line:)` 函数来指示发生了故障——例如，如果采取了开关的默认情况，但所有的有效情况都应被匹配的情况。

如果以非检查模式编译（-Ounchecked），则不会检查前提条件。编译器假定前置条件总是正确的，并相应的优化了代码。但是，无论优化如何设置，`fatalError(_:file:line:)` 函数都会执行。

在原型开发和早期开发过程中，可以使用 `fatalError(_:file:line:)` 函数为尚未实现的功能创建 stubs，方法是编写 `fatalError("Unimplemented")` 作为存根实现。由于 `fatalError(_:file:line:)` 永远不会被优化，与断言或先决条件不同，`fatalError(_:file:line:)` 可以确保始终执行。

其中最常见的用途就是在你自定义了初始化方法之后，编译器总是会自动帮你补上：
```
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
```
如果觉得我写的还不错，请关注我的微博[@小橘爷](http://weibo.com/yanghaoyu0225)，最新文章即时推送~