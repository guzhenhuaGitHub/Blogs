# 线程管理

OS X 或 iOS 中的每个进程（应用程序）都由一个或多个线程组成，每个线程表示通过应用程序代码执行的单个路径。每个应用程序都以单个线程开始，该线程运行应用程序的主要功能。应用程序可以产生额外的线程，每个线程执行特定功能的代码。

当一个应用程序产生一个新的线程时，该线程将成为应用程序进程空间内的一个独立的实体。每个线程都有自己的执行堆栈，并由内核独立调度运行时间。一个线程可以与其他线程和其他进程通信，执行 I/O 操作，并执行任何其他你可能需要的操作。但是，由于它们在同一个进程空间内，因此单个应用程序中的所有线程共享相同的虚拟内存空间，并具有与进程本身相同的访问权限。

本章概述 OS X 和 iOS 中可用的线程技术，以及如何在应用程序中使用这些技术的示例。

注意：有关 Mac OS 线程体系结构的历史观察以及有关线程的其他背景信息，请参阅技术说明 TN2028 “线程体系结构”。

## 线程成本

在内存使用和性能方面，线程对你的程序（和系统）有实际的成本。每个线程都需要在内核内存空间和程序的内存空间中分配内存。管理线程和协调其调度所需的核心结构使用有线存储器存储在内核中。你的线程的堆栈空间和每线程数据存储在程序的内存空间中。当你首次创建线程时，大多数这些结构都会创建并初始化 - 由于与内核进行必需的交互，该进程可能相对较为昂贵。

表2-1量化了与在应用程序中创建新用户级线程相关的近似成本。其中一些成本是可配置的，例如为辅助线程分配的堆栈空间量。创建线程的时间成本是一个粗略的近似值，应仅用于相互比较。线程创建时间可能因处理器负载，计算机速度以及可用系统和程序内存的数量而有很大差异。

表 2-1 线程创建成本
| Item | Approximate cost | Notes | 
| - | - | - |
| Kernel data structures | Approximately 1 KB | 该内存用于存储线程数据结构和属性，其中大部分分配为有线内存，因此无法分页到磁盘。 |  
| Stack space | 512 KB (secondary threads) 8 MB (OS X main thread) 1 MB (iOS main thread) | 辅助线程允许的最小堆栈大小为16 KB，堆栈大小必须是4 KB 的倍数。 这个内存的空间在创建线程的时候被放置在进程空间中，但是与该内存相关的实际页面只有在需要时才会被创建。 |
| Creation time | Approximately 90 microseconds | 该值反映了创建线程的初始调用与线程入口点例程开始执行的时间之间的时间。 这些数据是通过分析在基于 Intel 的 iMac 上使用 2 GHz Core Duo 处理器和1 GB 运行 OS X v10.5的 RAM 创建线程期间生成的平均值和中值而确定的。 |

注意：由于其基础内核支持，operation 对象通常可以更快地创建线程。 他们不是每次都从头开始创建线程，而是使用已驻留在内核中的线程池来节省分配时间。 有关使用 operation 对象的更多信息，请参见[并发编程指南](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)。

编写线程代码时需要考虑的另一个成本是生产成本。 设计线程应用程序有时可能需要对组织应用程序数据结构的方式进行根本性更改。 为避免使用同步，进行这些更改可能是必要的，这可能会对设计不当的应用程序造成巨大的性能损失。 设计这些数据结构并调试线程代码中的问题可能会增加开发线程应用程序所需的时间。 但是，避免这些成本会在运行时造成更大的问题，但是，如果你的线程花费太多时间等待锁定或什么都不做。

## 创建一个线程

创建低级线程相对简单。 在任何情况下，你都必须有一个函数或方法来充当线程的主入口点，并且你必须使用其中一个可用的线程例程来启动线程。 以下部分显示了更常用的线程技术的基本创建过程。 使用这些技术创建的线程将继承默认的一组属性，由你使用的技术决定。 有关如何配置线程的信息，请参阅[配置线程属性](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8)。

### 使用 NSThread

有两种使用 [NSThread](https://developer.apple.com/documentation/foundation/nsthread) 类创建线程的方法：

- 使用 [detachNewThreadSelector:toTarget:withObject:](https://developer.apple.com/documentation/foundation/thread/1415633-detachnewthreadselector) 类方法来产生新的线程。
- 创建一个新的 NSThread 对象并调用其启动方法。 （仅在 iOS 和 OS X v10.5 及更高版本中受支持。）

这两种技术都会在应用程序中创建一个分离线程。分离线程意味着线程退出时线程的资源会被系统自动回收。这也意味着你的代码不需要以后明确加入到线程中。

因为 detachNewThreadSelector:toTarget:withObject: 方法在所有版本的 OS X 中都受支持，所以在现有的使用线程的 Cocoa 应用程序中经常会发现它。要分离新线程，只需提供你想要用作线程入口点的方法名称（指定为选择器），定义该方法的对象以及要在启动时传递给线程的任何数据。以下示例显示了此方法的基本调用，该方法使用当前对象的自定义方法生成线程。

```
[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];
```

在 OS X v10.5之前，你主要使用 NSThread 类来产生线程。虽然你可以得到一个 NSThread 对象并访问一些线程属性，但你只能在线程本身运行后才能这样做。在 OS X v10.5中，添加了用于创建 NSThread 对象而不立即产生相应新线程的支持。 （此支持在 iOS 中也可用。）此支持使得在启动线程之前可以获取和设置各种线程属性。它还使得可以使用该线程对象稍后引用正在运行的线程。

在 OS X v10.5及更高版本中初始化 NSThread 对象的简单方法是使用 [initWithTarget:selector:object:](https://developer.apple.com/documentation/foundation/nsthread/1414773-initwithtarget) 方法。此方法使用与 detachNewThreadSelector:toTarget:withObject: 方法完全相同的信息，并使用它来初始化新的 NSThread 实例。但是，它不启动线程。要启动线程，请明确调用线程对象的 start 方法，如下例所示：

```
NSThread* myThread = [[NSThread alloc] initWithTarget:self
                                        selector:@selector(myThreadMainMethod:)
                                        object:nil];
[myThread start];  // Actually create the thread
```

> 注意：使用 [initWithTarget:selector:object:](https://developer.apple.com/documentation/foundation/nsthread/1414773-initwithtarget)  方法的替代方法是对 NSThread 进行子类化并覆盖其主要方法。你可以使用此方法的重写版本来实现线程的主入口点。有关更多信息，请参阅 [NSThread 类参考](https://developer.apple.com/documentation/foundation/thread)中的子类注释。

如果你有一个线程当前正在运行的 NSThread 对象，则可以将消息发送到该线程的一种方式是使用应用程序中几乎任何对象的 [performSelector:onThread:withObject:waitUntilDone:](https://developer.apple.com/documentation/objectivec/nsobject/1414476-perform) 方法。在 OS X v10.5中引入了对线程（主线程除外）执行选择器的支持，并且是在线程之间进行通信的便捷方式。 （此支持在 iOS 中也可用。）使用此技术发送的消息由其他线程直接执行，作为其正常运行循环处理的一部分。 （当然，这意味着目标线程必须在其运行循环中运行;参见运行循环）。当你以这种方式进行通信时，你仍然可能需要某种形式的同步，但它比在通信端口之间设置通信端口更简单线程。

注意：虽然适用于线程之间的偶然通信，但不应使用 performSelector:onThread:withObject:waitUntilDone: 方法来处理线程之间的时间关键或频繁通信。

有关其他线程通信选项的列表，请参阅[设置线程的分离状态](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3)。

### 使用 POSIX 线程

OS X 和 iOS 为使用 POSIX 线程 API 创建线程提供基于 C 的支持。 该技术实际上可以用于任何类型的应用程序（包括 Cocoa 和 Cocoa Touch 应用程序），如果您正在为多个平台编写软件，该技术可能会更方便。 你用来创建线程的 POSIX 例程被调用，足够恰当，pthread_create。

清单2-1显示了两个使用 POSIX 调用创建线程的自定义函数。 LaunchThread 函数创建一个新的线程，其主例程在 PosixThreadMainRoutine 函数中实现。 由于 POSIX 默认将线程创建为可连接，因此此示例更改线程的属性以创建分离的线程。 将线程标记为已分离，可让系统在退出时立即为该线程回收资源。

清单 2-1 在 C 中创建一个线程

```
#include <assert.h>
#include <pthread.h>
 
void* PosixThreadMainRoutine(void* data)
{
    // Do some work here.
 
    return NULL;
}
 
void LaunchThread()
{
    // Create the thread using POSIX routines.
    pthread_attr_t  attr;
    pthread_t       posixThreadID;
    int             returnVal;
 
    returnVal = pthread_attr_init(&attr);
    assert(!returnVal);
    returnVal = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    assert(!returnVal);
 
    int     threadError = pthread_create(&posixThreadID, &attr, &PosixThreadMainRoutine, NULL);
 
    returnVal = pthread_attr_destroy(&attr);
    assert(!returnVal);
    if (threadError != 0)
    {
         // Report an error.
    }
}
```

如果将前面列表中的代码添加到其中一个源文件并调用 LaunchThread 函数，它将在你的应用程序中创建一个新的分离线程。当然，使用这段代码创建的新线程不会做任何有用的事情。线程将启动并几乎立即退出。为了使事情更有趣，你需要将代码添加到 PosixThreadMainRoutine 函数中以完成一些实际工作。为了确保线程知道要做什么工作，可以在创建时向它传递一个指向某些数据的指针。你将此指针作为 pthread_create 函数的最后一个参数传递。

为了将新创建的线程的信息传递回应用程序的主线程，需要在目标线程之间建立通信路径。对于基于 C 的应用程序，线程之间有多种通信方式，包括使用端口，条件或共享内存。对于长寿命的线程，几乎总是应该设置某种线程间通信机制，以便为应用程序的主线程检查线程的状态或在应用程序退出时干净地关闭线程。

有关 POSIX 线程函数的更多信息，请参见 pthread 手册页。

### 使用 NSObject 来产生一个线程

在 iOS 和 OS X v10.5及更高版本中，所有对象都能够生成一个新线程并使用它来执行其中一个方法。 [performSelectorInBackground:withObject:](https://developer.apple.com/documentation/objectivec/nsobject/1412390-performselectorinbackground) 方法创建一个新的分离线程，并使用指定的方法作为新线程的入口点。例如，如果你有一些对象（由变量 myObj 表示），并且该对象有一个名为 doS​​omething 的方法，你想在后台线程中运行该方法，则可以使用以下代码执行此操作：

```
[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];
```

调用此方法的效果与将当前对象，选择器和参数对象作为参数调用 [detachNewThreadSelector:toTarget:withObject:](https://developer.apple.com/documentation/foundation/thread/1415633-detachnewthreadselector) [NSThread](https://developer.apple.com/documentation/foundation/nsthread) 方法的效果相同。新线程立即使用默认配置生成并开始运行。在选择器内部，你必须像任何线程一样配置线程。例如，你需要设置一个自动释放池（如果你没有使用垃圾收集）并且配置线程的运行循环，如果你打算使用它的话。有关如何配置新线程的信息，请参阅[配置线程属性](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8)。

### 在 Cocoa 应用程序中使用 POSIX 线程

尽管 NSThread 类是在 Cocoa 应用程序中创建线程的主要接口，但如果这样做更方便，你可以自由使用 POSIX 线程。例如，如果你已经有使用它们的代码并且你不想重写它，则可以使用 POSIX 线程。如果你打算在 Cocoa 应用程序中使用 POSIX 线程，你仍然应该了解 Cocoa 和线程之间的交互，并遵循以下部分的指导原则。

#### 保护 Cocoa 框架

对于多线程应用程序，Cocoa 框架使用锁和其他形式的内部同步来确保它们的行为正确。但是，为了防止这些锁在单线程情况下降低性能，Cocoa 不会在应用程序使用 NSThread 类生成其第一个新线程之前创建它们。如果你仅使用 POSIX 线程例程生成线程，则 Cocoa 不会收到它需要知道您的应用程序现在是多线程的通知。当发生这种情况时，涉及 Cocoa 框架的操作可能会破坏应用程序的稳定性或崩溃。

为了让 Cocoa 知道你打算使用多线程，你所要做的就是使用 NSThread 类生成一个单线程，并让该线程立即退出。你的线程入口点不需要做任何事情。使用 NSThread 产生线程的行为足以确保 Cocoa 框架所需的锁定到位。

如果你不确定 Cocoa 是否认为你的应用程序是多线程的，则可以使用 NSThread 的 isMultiThreaded 方法进行检查。

#### 混合 POSIX 和 Cocoa 锁

在同一个应用程序中使用 POSIX 和 Cocoa 锁的混合是安全的。Cocoa 锁和条件对象实质上只是 POSIX 互斥体和条件的包装器。但是，对于给定的锁，你必须始终使用相同的接口来创建和操作该锁。换句话说，你不能使用 Cocoa NSLock 对象来操纵你使用 pthread_mutex_init 函数创建的互斥锁，反之亦然。

## 配置线程属性

在创建线程之后（有时在之前），你可能需要配置线程环境的不同部分。 以下各节介绍了你可以进行的一些更改以及何时可以进行的更改。

### 配置线程的堆栈大小

对于你创建的每个新线程，系统都会在你的进程空间中分配特定数量的内存以充当该线程的堆栈。 堆栈管理堆栈帧，也是声明线程的任何局部变量的地方。 分配给线程的内存量在线程成本中列出。

如果你想更改给定线程的堆栈大小，则必须在创建线程之前执行此操作。 尽管使用 NSThread 设置堆栈大小仅适用于 iOS 和 OS X v10.5及更高版本，但所有线程技术都提供了一些设置堆栈大小的方法。 表2-2列出了每种技术的不同选项。

表 2-2 设置线程的堆栈大小
| Technology | Option |
| - | - |
| Cocoa | 在 iOS 和 OS X v10.5及更高版本中，分配并初始化 NSThread 对象（不要使用 [detachNewThreadSelector:toTarget:withObject:](https://developer.apple.com/documentation/foundation/thread/1415633-detachnewthreadselector) 方法）。 在调用线程对象的 start 方法之前，请使用 [setStackSize:](https://developer.apple.com/documentation/foundation/nsthread/1415190-stacksize) 方法来指定新的堆栈大小。 |
| POSIX | 创建一个新的 pthread_attr_t 结构并使用 pthread_attr_setstacksize 函数更改默认堆栈大小。 创建线程时，将属性传递给 pthread_create 函数。 |
| Multiprocessing Services | 创建线程时，将相应的堆栈大小值传递给 MPCreateTask 函数。 |

### 配置线程本地存储

每个线程维护一个可以从线程中的任何位置访问的键值对的字典。 你可以使用此字典来存储你希望在整个线程执行期间保持的信息。 例如，你可以使用它来存储你希望通过线程运行循环的多次迭代来持久化的状态信息。

Cocoa 和 POSIX 以不同的方式存储线程字典，所以你不能混合和匹配这两种技术。 但是，只要你在线程代码中坚持使用一种技术，最终结果应该是相似的。 在 Cocoa 中，你使用 [NSThread](https://developer.apple.com/documentation/foundation/nsthread) 对象的 [threadDictionary](https://developer.apple.com/documentation/foundation/thread/1411433-threaddictionary) 方法来检索一个 NSMutableDictionary 对象，你可以在其中添加你的线程所需的任何键。 在 POSIX 中，你使用 pthread_setspecific 和 pthread_getspecific 函数来设置和获取线程的键和值。

### 设置线程的分离状态

大多数高级线程技术默认创建分离的线程。在大多数情况下，分离线程是首选，因为它们允许系统在完成线程后立即释放线程的数据结构。分离的线程也不需要与你的程序进行明确的交互。从线程检索结果的方法由你自行决定。相比之下，系统不会回收可连接线程的资源，直到另一个线程显式地与该线程连接，这个进程可能会阻塞执行连接的线程。

你可以将可连接线程看作类似于子线程。虽然它们仍然作为独立线程运行，但可连接线程必须由另一个线程连接，然后才能由系统回收资源。可连接线程还提供了将数据从一个正在退出的线程传递到另一个线程的明确方法。就在它退出之前，可联接线程可以将数据指针或其他返回值传递给 pthread_exit 函数。然后另一个线程可以通过调用 pthread_join 函数声明这些数据。

> 重要提示：在应用程序退出时，分离的线程可以立即终止，但可连接的线程不能。必须在允许退出进程之前连接每个可连接的线程。因此，在线程正在执行不应中断的关键工作（如将数据保存到磁盘）的情况下，可连接线程可能更可取。

如果你想创建可连接的线程，唯一的方法是使用 POSIX 线程。 POSIX 默认将线程创建为可连接。要将线程标记为分离或可连接，请在创建线程之前使用 pthread_attr_setdetachstate 函数修改线程属性。线程开始后，你可以通过调用 pthread_detach 函数将可连接线程更改为分离线程。有关这些 POSIX 线程函数的更多信息，请参见 pthread 手册页。有关如何与线程连接的信息，请参阅 pthread_join 手册页。

### 设置线程优先级

你创建的任何新线程都具有与其关联的默认优先级。内核的调度算法在确定要运行哪些线程时考虑线程优先级，优先级较高的线程比较低优先级的线程更有可能运行。较高的优先级不能保证线程执行时间的具体数量，只是与较低优先级的线程相比，调度程序更有可能选择它。

> 重要提示：将线程的优先级保留为默认值通常是一个好主意。增加一些线程的优先级也增加了在较低优先级的线程中出现饥饿的可能性。如果你的应用程序包含必须彼此交互的高优先级和低优先级线程，则较低优先级线程的缺乏可能会阻塞其他线程并导致性能瓶颈。

如果你确实想修改线程优先级，Cocoa 和 POSIX 都可以这样做。对于 Cocoa 线程，你可以使用 [NSThread](https://developer.apple.com/documentation/foundation/nsthread) 的 [setThreadPriority:](https://developer.apple.com/documentation/foundation/nsthread/1407523-setthreadpriority) 类方法来设置当前正在运行的线程的优先级。对于 POSIX 线程，你可以使用 pthread_setschedparam 函数。有关更多信息，请参阅 [NSThread 类参考](https://developer.apple.com/documentation/foundation/thread)或 pthread_setschedparam 手册页。

## 编写你的线程入口例程

大多数情况下，线程入口点例程的结构在 OS X 中与其他平台上的结构相同。你初始化你的数据结构，做一些工作或者可选地设置一个运行循环，并在你的线程代码完成时清理。根据你的设计，在编写入门例程时可能需要执行一些额外的步骤。

### 创建一个 Autorelease 池

在 Objective-C 框架中链接的应用程序通常必须在其每个线程中至少创建一个自动释放池。如果应用程序使用托管模型（应用程序处理保留和释放对象的位置），autorelease 池将捕获该线程中自动释放的所有对象。

如果应用程序使用垃圾回收而不是托管内存模型，则不需要创建 autorelease 池。垃圾收集应用程序中的自动释放池的存在并不会造成危害，大多数情况下都会被忽略。它允许代码模块必须同时支持垃圾回收和托管内存模型的情况。在这种情况下，必须存在 autorelease 池才能支持托管内存模型代码，并且如果应用程序在启用垃圾回收的情况下运行，则会被忽略。

如果你的应用程序使用托管内存模型，那么创建自动释放池应该是你在线程入口例程中首先执行的操作。同样，销毁这个自动释放池应该是你在线程中做的最后一件事。该池确保自动释放的对象被捕获，尽管在线程本身退出之前它不会释放它们。清单2-2显示了使用 autorelease 池的基本线程入口例程的结构。

清单 2-2 定义线程入口点例程

```
- (void)myThreadMainRoutine
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Top-level pool
 
    // Do thread work here.
 
    [pool release];  // Release the objects in the pool.
}
```

由于顶级自动释放池在线程退出前不会释放其对象，因此长期线程应创建更多的自动释放池来更频繁地释放对象。 例如，使用运行循环的线程可能会在每次运行循环时创建并释放自动释放池。 更频繁地释放对象可防止应用程序的内存占用过大，从而导致性能问题。 与任何与性能相关的行为一样，你应该测量代码的实际性能，并适当调整对 autorelease 池的使用。

有关内存管理和自动释放池的更多信息，请参阅[高级内存管理编程指南](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i)。

### 设置一个异常处理程序

如果你的应用程序捕获并处理异常，则应准备好你的线程代码以捕获可能发生的任何异常。 尽管最好在它们可能发生的地方处理异常，但如果未能在线程中捕获抛出的异常，则会导致应用程序退出。 在线程入口例程中安装最终的 try/catch 可以让你捕获任何未知的异常并提供适当的响应。

在 Xcode 中构建项目时，你可以使用 C++ 或 Objective-C 异常处理样式。 有关设置如何在 Objective-C 中引发和捕获异常的信息，请参阅[异常编程主题](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i)。

### 设置运行循环

在编写代码时，你希望在单独的线程上运行，你有两种选择。 第一种选择是将线程的代码编写成一个很少或根本不中断的长任务，并在线程完成时退出线程。 第二个选项是把你的线程放到一个循环中，让它在到达时动态地处理请求。 第一个选项不需要为你的代码进行特殊设置; 你只是开始做你想做的工作。 然而，第二个选项涉及设置线程的运行循环。

OS X 和 iOS 为在每个线程中实现运行循环提供了内置支持。 应用程序框架自动启动应用程序主线程的运行循环。 如果你创建任何辅助线程，则必须配置运行循环并手动启动它。

有关使用和配置运行循环的信息，请参阅[运行循环](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)。

## 终止线程

建议退出线程的方式是让它通常退出入口点例程。尽管 Cocoa，POSIX 和 Multiprocessing Services 提供了直接杀死线程的例程，但是强烈建议不要使用这样的例程。杀死一个线程可以防止线程自行清理。由该线程分配的内存可能会泄漏，并且线程当前正在使用的任何其他资源可能无法正确清理，从而在稍后创建潜在问题。

如果你预计需要在操作过程中终止线程，则应该从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到了这样的消息。如果消息确实要求线程退出，线程将有机会执行任何需要的清理并正常退出;否则，它可能会重新开始工作并处理下一块数据。

响应取消消息的一种方法是使用运行循环输入源来接收此类消息。清单2-3显示了这个代码在你的线程主入口例程中的外观结构。 （该示例仅显示主循环部分，不包括设置自动释放池或配置实际工作的步骤。）该示例在运行循环中安装自定义输入源，该输入源可能会从另一个你的线程;有关设置输入源的信息，请参阅配置运行循环源。执行完工作总量的一部分后，线程会短暂运行运行循环以查看消息是否到达输入源。如果没有，运行循环立即退出，循环继续下一个工作。因为处理程序不能直接访问 exitNow 局部变量，所以退出条件通过线程字典中的键值对传递。

清单 2-3 在长时间工作中检查退出条件

```
- (void)threadMainRoutine
{
    BOOL moreWorkToDo = YES;
    BOOL exitNow = NO;
    NSRunLoop* runLoop = [NSRunLoop currentRunLoop];
 
    // Add the exitNow BOOL to the thread dictionary.
    NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];
    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@"ThreadShouldExitNow"];
 
    // Install an input source.
    [self myInstallCustomInputSource];
 
    while (moreWorkToDo && !exitNow)
    {
        // Do one chunk of a larger body of work here.
        // Change the value of the moreWorkToDo Boolean when done.
 
        // Run the run loop but timeout immediately if the input source isn't waiting to fire.
        [runLoop runUntilDate:[NSDate date]];
 
        // Check to see if an input source handler changed the exitNow value.
        exitNow = [[threadDict valueForKey:@"ThreadShouldExitNow"] boolValue];
    }
}
```

> 如果觉得我写的还不错，请关注我的微博[@小橘爷](http://weibo.com/yanghaoyu0225)，最新文章即时推送~