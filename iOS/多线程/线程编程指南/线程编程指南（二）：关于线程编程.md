# 关于线程编程

多年来，计算机的最高性能在很大程度上受限于计算机核心处的单个微处理器的速度。 然而，随着单个处理器的速度开始达到其实际限制，芯片制造商切换到多核设计，使计算机有机会同时执行多个任务。 虽然 OS X 只要能够执行与系统相关的任务就可以利用这些内核，但你自己的应用程序也可以通过线程利用它们。 

## 什么是线程？

线程是在应用程序内部实现多个执行路径的相对轻量级的方式。在系统层面，程序并排运行，系统根据其需求和其他程序的需求，为每个程序分配执行时间。但是，在每个程序中，存在一个或多个执行线程，这些线程可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理着这些执行线程，调度它们在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。

从技术角度来看，线程是管理代码执行所需的内核级和应用级数据结构的组合。内核级别的结构协调事件对线程的调度和线程在其中一个可用内核上的抢先调度。应用程序级结构包括用于存储函数调用的调用堆栈以及应用程序需要管理和操作线程的属性和状态的结构。

在非并发应用程序中，只有一个执行线程。该线程以应用程序的 main 例程开始和结束，并逐个分支到不同的方法或函数，以实现应用程序的整体行为。相比之下，支持并发的应用程序从一个线程开始，并根据需要添加更多来创建额外的执行路径。每个新路径都有自己的自定义启动例程，它独立于应用程序 main 例程中的代码运行。在应用程序中有多个线程提供了两个非常重要的潜在优势：

- 多个线程可以提高应用程序的感知响应能力。
- 多线程可以提高应用程序在多核系统上的实时性能。

如果你的应用程序只有一个线程，那么这个线程必须做所有事情。它必须响应事件，更新应用程序的窗口，并执行实现应用程序行为所需的所有计算。只有一个线程的问题是它一次只能做一件事。那么当你的一个计算需要很长时间才能完成时会发生什么？当你的代码忙于计算它所需的值时，应用程序会停止响应用户事件并更新其窗口。如果这种行为持续时间足够长，用户可能会认为你的应用程序被挂起并试图强行退出它。但是，如果将自定义计算移至单独的线程，则应用程序的主线程可以更及时地自由响应用户交互。

随着多核计算机的普及，线程提供了一种提高某些类型应用程序性能的方法。执行不同任务的线程可以在不同的处理器内核上同时执行，从而使应用程序可以在给定的时间内增加工作量。

当然，线程并不是解决应用程序性能问题的灵丹妙药。随着线程提供的好处带来了潜在的问题。在应用程序中执行多个路径可能会增加代码的复杂度。每个线程必须将其动作与其他线程协调以防止其破坏应用程序的状态信息。由于单个应用程序中的线程共享相同的内存空间，因此它们可以访问所有相同的数据结构。如果两个线程试图同时操纵相同的数据结构，则一个线程可能会以破坏结果数据结构的方式覆盖另一个线程的更改。即使有适当的保护措施，你仍然需要注意编译器优化，这些编译器优化会在你的代码中引入微妙（和不那么微妙）的错误。

## 线程术语

在讨论线程及其支持技术之前，有必要定义一些基本术语。

如果你熟悉 UNIX 系统，则可能会发现本文档中使用的术语“task”有所不同。 在 UNIX 系统上，有时使用术语“task”来指代正在运行的进程。

本文件采用以下术语：

- 术语线程(thread)用于指代码的单独执行路径。
- 术语过程(process)用于指代正在运行的可执行文件，它可以包含多个线程。
- 术语任务(task)用于指需要执行的抽象工作概念。

## 线程的替代方法

自己创建线程的一个问题是它们会给代码添加不确定性。线程是一种相对较低级别且复杂的方式来支持应用程序中的并发。如果你不完全了解设计选择的含义，则可能会遇到同步或时间问题，其严重程度可能会从微妙的行为变化到应用程序崩溃以及用户数据的损坏。

另一个要考虑的因素是你是否需要线程或并发。线程解决了如何在同一进程内同时执行多个代码路径的具体问题。但是，有些情况下，你所做的工作量并不能保证并发。线程为你的进程带来了巨大的开销，无论是在内存消耗和 CPU 时间方面。你可能会发现这种开销对于预期的任务来说太大了，或者其他选项更容易实现。

表1-1列出了线程的一些替代方法。该表包括线程的替换技术（如 operation 对象和 GCD）以及适用于有效使用你已有的单线程的替代技术。

表 1-1 线程的替代技术

| Technology | Description |
| - | - |
| Operation objects | 在 OS X v10.5 中引入的 operation 对象是通常在辅助线程上执行的任务的包装器。 这个包装器隐藏了执行任务的线程管理方面，让你可以自由地专注于任务本身。 通常将这些对象与一个 operation queue 对象结合使用，该对象实际上管理一个或多个线程上的 operation 对象的执行。 有关如何使用 operation 对象的更多信息，请参见[并发编程指南](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)。|
| Grand Central Dispatch (GCD) | 在 Mac OS x v10.6 中引入的 Grand Central Dispatch 是线程的另一种替代方案，可让你专注于执行所需的任务而不是线程管理。 使用 GCD，你可以定义要执行的任务并将其添加到工作队列中，该工作队列可以在适当的线程上处理你的任务计划。 工作队列考虑可用内核的数量和当前负载，以便比使用线程更有效地执行任务。 有关如何使用 GCD 和工作队列的信息，请参阅[并发编程指南](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)|
| Idle-time notifications | 对于相对较短且优先级非常低的任务，空闲时间通知可让你在应用程序不太忙时执行任务。 Cocoa 使用 NSNotificationQueue 对象为空闲时间通知提供支持。 要请求空闲时间通知，请使用 [NSPostWhenIdle](https://developer.apple.com/documentation/foundation/nspostingstyle/nspostwhenidle) 选项向默认 [NSNotificationQueue](https://developer.apple.com/documentation/foundation/notificationqueue) 对象发布通知。 队列会延迟通知对象的传递，直到运行循环变为空闲状态。 有关更多信息，请参阅[通知编程主题](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i)。 |
| Asynchronous functions | 系统接口包含许多为你提供自动并发性的异步功能。 这些 API 可以使用系统守护进程和进程，或创建自定义线程来执行他们的任务并将结果返回给你。 （实际的实现是无关的，因为它与代码是分开的。）在设计应用程序时，寻找提供异步行为的函数，并考虑使用它们而不是在自定义线程上使用等效的同步函数。 |
| Timers | 你可以在你的应用程序主线程上使用定时器来执行定期任务，这些任务对于需要线程而言太重要，但仍需要定期进行维护。 有关定时器的信息，请参阅[定时器源](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21)。 |
| Separate processes | 虽然比线程更重量级，但在任务仅与应用程序切线相关的情况下，创建单独的进程可能很有用。 如果任务需要大量内存或必须使用 root 权限执行，则可以使用进程。 例如，你可以使用64位服务器进程来计算大型数据集，而你的32位应用程序会将结果显示给用户。 |

> 警告：使用 fork 函数启动单独的进程时，必须始终使用调用 exec 或类似函数的方式调用 fork。 依赖于 Core Foundation，Cocoa 或 Core Data 框架（显式或隐式）的应用程序必须对 exec 函数进行后续调用，否则这些框架的行为可能会不正确。

## 线程支持

如果你现有的代码使用线程，则 OS X 和 iOS 提供了多种技术来在你的应用程序中创建线程。 另外，这两个系统还为管理和同步这些线程上需要完成的工作提供支持。 以下各节介绍了在 OS X 和 iOS 中使用线程时需要注意的一些关键技术。

### 线程包

虽然线程的底层实现机制是 Mach 线程，但你很少（如果有的话）在 Mach 级别使用线程。 相反，你通常使用更方便的 POSIX API 或其衍生工具之一。 Mach 实现确实提供了所有线程的基本特征，但是，包括抢先执行模型和调度线程的能力，因此它们彼此独立。

清单2-2列出了你可以在应用程序中使用的线程技术。

表 1-2 线程技术
| Technology | Description |
| - | - |
| Cocoa threads | Cocoa 使用 [NSThread](https://developer.apple.com/documentation/foundation/nsthread) 类实现线程。 Cocoa 还提供 [NSObject](https://developer.apple.com/documentation/objectivec/nsobject) 上的方法来生成新线程并在已经运行的线程上执行代码。 有关更多信息，请参阅[使用 NSThread](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11) 和[使用 NSObject 生成线程](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13)。 | 
| POSIX threads | POSIX 线程为创建线程提供了一个基于 C 的接口。 如果你没有编写一个 Cocoa 应用程序，这是创建线程的最佳选择。 POSIX 接口使用起来相对简单，并为配置线程提供了足够的灵活性。 有关更多信息，请参阅[使用 POSIX 主题](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12) |
| Multiprocessing Services | 多处理服务是一个传统的基于 C 的接口，用于从旧版 Mac OS 转换而来的应用程序。 这项技术仅适用于 OS X，应该避免任何新的开发。 相反，你应该使用 NSThread 类或 POSIX 线程。 如果你需要有关此技术的更多信息，请参阅多处理服务编程指南。 |

在应用程序级别，所有线程的行为与其他平台上的行为基本相同。启动线程后，线程将以三种主要状态之一运行：运行，准备就绪或挂起。如果一个线程当前没有运行，它将被阻塞并等待输入，或者它已准备好运行，但尚未安排执行。线程继续在这些状态之间来回移动，直到它最终退出并移动到终止状态。

当你创建一个新线程时，你必须为该线程指定一个入口函数（或 Cocoa 线程的入口点方法）。这个入口函数构成了你想要在线程上运行的代码。当函数返回时，或者当你明确终止线程时，该线程会永久停止并由系统回收。由于线程在内存和时间方面创建起来相对昂贵，因此建议你的入口点函数执行大量工作或设置运行循环以允许执行重复性工作。

有关可用线程技术以及如何使用它们的更多信息，请参阅[线程管理](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2)。

### 运行循环

运行循环是用于管理在线程上异步到达的事件的基础设施。运行循环通过监视线程的一个或多个事件源来工作。当事件到达时，系统唤醒线程并将事件分派给运行循环，然后运行循环将其分派给你指定的处理程序。如果没有事件存在并准备好处理，则运行循环将使线程进入休眠状态。

你不需要在创建任何线程时使用运行循环，但这样做可以为用户提供更好的体验。运行循环可以创建使用最少量资源的长效线程。由于运行循环会在无所事事时将线程置于休眠状态，因此无需轮询，浪费 CPU 周期并防止处理器本身进入休眠状态并节省功耗。

要配置运行循环，你只需启动线程，获取对运行循环对象的引用，安装事件处理程序并指示运行循环运行。 OS X 提供的基础架构自动为你处理主线程运行循环的配置。但是，如果你打算创建长寿命的辅助线程，则必须自行为这些线程配置运行循环。

有关运行循环的详细信息以及如何使用它们的示例在 [Run Loops](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1) 中提供。

### 同步工具

线程编程的一个危险是多线程间的资源争用。如果多个线程尝试同时使用或修改相同的资源，则可能会出现问题。缓解问题的一种方法是完全消除共享资源，并确保每个线程都有自己独特的资源集合来运行。但是，当保持完全独立的资源不是一个选项时，你可能必须使用锁，条件，原子操作和其他技术来同步对资源的访问。

锁对于一次只能由一个线程执行的代码提供蛮力保护形式。最常见的类型是互斥锁，也称为互斥锁。当一个线程试图获取另一个线程当前拥有的互斥体时，它会阻塞，直到另一个线程释放该锁。几个系统框架为互斥锁提供支持，尽管它们都基于相同的基础技术。另外，Cocoa 提供了互斥锁的几种变体来支持不同类型的行为，比如递归。有关可用类型的锁的更多信息，请参见[锁](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126320)。

除了锁之外，系统还为条件提供支持，以确保在应用程序中对任务进行正确排序。条件充当守门人，阻塞给定的线程，直到它所表示的条件变为真。当这种情况发生时，条件释放线程并允许它继续。 POSIX 层和 Foundation 框架都为条件提供了直接支持。 （如果使用 operation 对象，则可以配置操作对象之间的依赖关系来排序任务的执行，这与条件提供的行为非常相似。）

虽然锁和条件在并发设计中非常常见，但原子操作是保护和同步数据访问的另一种方式。在可以对标量数据类型执行数学或逻辑运算的情况下，原子操作提供了一种轻量级的替代方法。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

有关可用同步工具的更多信息，请参阅[同步工具](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887)。

### 线程间通信

尽管一个好的设计可以最大限度地减少所需的通信量，但在某些时候，线程之间的通信变得必要。 （线程的工作是为你的应用程序工作，但如果从未使用该作业的结果，它有什么用处？）线程可能需要处理新的工作请求或将其进度报告给应用程序的主线程。在这些情况下，你需要一种从一个线程向另一个线程获取信息的方法。幸运的是，线程共享相同的进程空间的事实意味着你有很多通信选项。

线程之间有许多交流的方式，每种方式都有自己的优点和缺点。配置线程本地存储器列出了你可以在 OS X 中使用的最常用的通信机制。（除了消息队列和 Cocoa 分布式对象，这些技术在 iOS 中也可用。）此表中的技术按照增加的顺序列出复杂。

表 1-3 通信机制

| Mechanism | Description |
| - | - |
| Direct messaging | Cocoa 应用程序支持直接在其他线程上执行选择器的功能。 这个能力意味着一个线程可以基本上在任何其他线程上执行一个方法。 由于它们是在目标线程的上下文中执行的，因此以这种方式发送的消息会自动在该线程上序列化。 有关输入源的信息，请参阅 [Cocoa 执行选择器源](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44)。 |
| Global variables, shared memory, and objects | 在两个线程之间传递信息的另一种简单方法是使用全局变量，共享对象或共享内存块。 虽然共享变量很快且简单，但它们比直接消息更脆弱。 共享变量必须用锁或其他同步机制小心保护，以确保代码的正确性。 不这样做可能会导致竞争状况，数据损坏或崩溃。 |
| Conditions | 条件是一个同步工具，你可以使用它来控制线程何时执行特定代码部分。 你可以将条件视为守门员，让线程只有在符合条件时才能运行。 有关如何使用条件的信息，请参阅[使用条件](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4)。 |
| Run loop sources | 自定义运行循环源是你设置为在线程上接收特定于应用程序的消息的源循环源。 因为它们是事件驱动的，所以当没有任何事情可以做时，运行循环源让你的线程自动进入睡眠状态，这可以提高线程的效率。 有关运行循环和运行循环源的信息，请参阅[运行循环](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)。 |
| Ports and sockets | 基于端口的通信是两个线程间通信的更复杂的方式，但它也是一种非常可靠的技术。 更重要的是，端口和套接字可用于与外部实体（如其他进程和服务）进行通信。 为了提高效率，端口是使用运行循环源实现的，所以当没有数据在端口上等待时，线程会休眠。 有关运行循环和有关基于端口的输入源的信息，请参阅[运行循环](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)。 |
| Message queues | 传统的多处理服务定义了用于管理传入和传出数据的先进先出（FIFO）队列抽象。 尽管消息队列简单方便，但并不像其他通信技术那样高效。 有关如何使用消息队列的更多信息，请参阅多处理服务编程指南。 |
| Cocoa distributed objects | 分布式对象是一种 Cocoa 技术，提供基于端口通信的高级实现。 虽然有可能使用这种技术进行线程间通信，但由于其发生的开销很大，因此非常不鼓励。 分布式对象更适合与其他进程进行通信，其中进程之间的开销已经很高。 有关更多信息，请参阅分布式对象编程主题。 |

## 设计技巧

以下各节提供的指导原则可帮助你以确保代码正确性的方式实现线程。 其中一些准则还提供了使用自己的线程代码实现更高性能的技巧。 与任何性能提示一样，你应该始终在更改代码之前，之中和之后收集相关性能统计信息。

### 避免明确地创建线程

手动编写线程创建代码非常繁琐且可能容易出错，应尽可能避免它。 OS X 和 iOS 通过其他 API 为并发提供隐式支持。 你可以考虑使用异步 API，GCD 或 operation 对象来完成工作，而不是自己创建线程。 这些技术为你幕后做与线程相关的工作，并保证正确执行。 另外，像 GCD 和 operation 对象这样的技术可以通过根据当前系统负载调整活动线程的数量，从而比自己的代码更高效地管理线程。 有关 GCD 和 operation 对象的更多信息，请参见[并发编程指南](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)。 

### 保持你的线程合理繁忙

如果你决定手动创建和管理线程，请记住线程会占用宝贵的系统资源。 你应该尽最大努力确保你分配给主题的任何任务都具有相当长的寿命和生产力。 同时，你不应该害怕终止大部分闲置时间的线程。 线程使用一个不重要的内存量，其中一些内存是有限的，因此释放一个空闲线程不仅有助于减少应用程序的内存占用量，还可释放更多物理内存供其他系统进程使用。

> 重要提示：在开始终止空闲线程之前，你应该始终记录应用程序当前性能的一组基线测量结果。 在尝试更改之后，请进行其他测量以验证这些更改是否实际上改善了性能，而不是伤害它。

### 避免共享数据结构

避免与线程相关的资源冲突的最简单和最简单的方法是为程序中的每个线程提供它所需的任何数据的副本。 当你最小化线程间的通信和资源争用时，并行代码效果最佳。

创建多线程应用程序很困难。 即使你非常小心并且在你的代码的所有正确时刻锁定了共享的数据结构，你的代码仍然可能在语义上是不安全的。 例如，如果你希望共享数据结构按特定顺序修改，你的代码可能会遇到问题。 将你的代码更改为基于事务的模型以进行补偿可能会随后取消具有多个线程的性能优势。 首先消除资源争夺往往导致设计更简单，性能优异。

### 线程和您的用户界面

如果你的应用程序具有图形用户界面，则建议你接收与用户相关的事件并从应用程序的主线程启动界面更新。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。一些框架，比如 Cocoa，通常需要这种行为，但即使对于那些不这样做的行为，在主线程上保持这种行为的优点是简化了管理用户界面的逻辑。

有一些值得注意的例外是从其他线程执行图形操作是有利的。例如，你可以使用辅助线程来创建和处理图像并执行其他图像相关的计算。使用辅助线程进行这些操作可以大大提高性能。如果你不确定特定的图形操作，请计划从你的主线程执行此操作。

有关 Cocoa 线程安全的更多信息，请参阅[线程安全摘要](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)。有关在 Cocoa 中绘制的更多信息，请参阅 [Cocoa 绘图指南](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290)。

### 在退出时注意线程行为

一个进程运行，直到所有未分离的线程退出。默认情况下，只有应用程序的主线程被创建为非分离，但你也可以创建其他线程。当用户退出应用程序时，通常认为适当的行为是立即终止所有分离的线程，因为分离线程完成的工作被认为是可选的。但是，如果应用程序使用后台线程将数据保存到磁盘或执行其他关键工作，则可能需要将这些线程创建为不分离，以防止应用程序退出时丢失数据。

将线程创建为非分离（也称为可连接）需要额外的工作。由于大多数高级线程技术默认情况下不创建可连接线程，因此你可能必须使用 POSIX API 来创建线程。此外，你必须将代码添加到应用程序的主线程，以便在最终退出时与非分离线程连接。有关创建可连接线程的信息，请参阅[设置线程的分离状态](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3)。

如果你正在编写一个 Cocoa 应用程序，你也可以使用 [applicationShouldTerminate:](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/1428642-applicationshouldterminate) delegate 方法来延迟应用程序的终止，直到稍后的时间或完全取消它。当延迟终止时，你的应用程序需要等到任何关键线程完成其任务，然后调用 [replyToApplicationShouldTerminate:](https://developer.apple.com/documentation/appkit/nsapplication/1428594-reply) 方法。有关这些方法的更多信息，请参阅 [NSApplication 类参考](https://developer.apple.com/documentation/appkit/nsapplication)。

### 处理异常

当引发异常时，异常处理机制依赖于当前的调用堆栈来执行任何必要的清理。由于每个线程都有自己的调用堆栈，因此每个线程都负责捕获它自己的异常。无法在辅助线程中捕获异常与在主线程中无法捕获异常的情况相同：拥有的进程已终止。你不能将未捕获的异常抛出到不同的线程进行处理。

如果你需要通知另一个线程（例如主线程）当前线程中的异常情况，则应该捕获该异常，并简单地向另一个线程发送消息，指示发生了什么。根据你的模型以及你正在尝试执行的操作，捕获异常的线程可以继续处理（如果可能的话），等待指令或退出。

> 注意：在 Cocoa 中，NSException 对象是一个自包含的对象，一旦它被捕获，它就可以从线程传递到线程。

在某些情况下，可能会自动为你创建异常处理程序。例如，Objective-C 中的 @synchronized 指令包含一个隐式异常处理程序。

### 干净地终止你的线程

当然，让线程退出的最好方式是让它到达主入口点例程的末尾。 尽管有立即终止线程的函数，但这些函数只能作为最后的手段使用。 在线程到达其自然终点之前终止线程可防止线程自行清理。 如果线程已分配内存，打开文件或获取其他类型的资源，则代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。

有关正确退出线程的更多信息，请参阅[终止线程](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW10)。

### 线程安全库

尽管应用程序开发人员可以控制应用程序是否使用多个线程执行，但库开发人员却不能。开发库时，你必须假定调用应用程序是多线程的，或者可以随时切换为多线程。因此，你应该始终使用锁代码的关键部分。

对于库开发人员来说，仅在应用程序变为多线程时才创建锁定是不明智的。如果你需要在某个时候锁定您的代码，请在使用库时尽早创建锁对象，最好在某种显式调用中初始化库。虽然你也可以使用静态库初始化函数来创建此类锁，但只有在没有其他方式时才尝试这样做。执行初始化函数会增加加载库所需的时间，并可能对性能产生不利影响。

注意：请始终记住平衡调用以锁定和解锁库中的互斥锁。你还应该记住要锁定库数据结构，而不是依赖调用代码来提供线程安全的环境。

如果你正在开发 Cocoa 库，如果你希望在应用程序变为多线程时收到通知，你可以注册为 [NSWillBecomeMultiThreadedNotification](https://developer.apple.com/documentation/foundation/nsnotification.name/1417567-nswillbecomemultithreaded) 的观察者。不过，你不应该依赖收到此通知，因为在你的库代码被调用之前它可能会被分派。

> 如果觉得我写的还不错，请关注我的微博[@小橘爷](http://weibo.com/yanghaoyu0225)，最新文章即时推送~